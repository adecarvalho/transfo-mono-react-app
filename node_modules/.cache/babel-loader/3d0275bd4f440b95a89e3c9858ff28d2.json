{"ast":null,"code":"/*!\n * The MIT License (MIT)\n * \n * Copyright (c) 2016 Mykhailo Stadnyk <mikhus@gmail.com>\n * \n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n * \n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n * \n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n *\n * @version 2.1.5\n */\n!function (e) {\n  \"use strict\";\n\n  function t(e) {\n    if (Array.isArray(e)) {\n      for (var t = 0, i = Array(e.length); t < e.length; t++) {\n        i[t] = e[t];\n      }\n\n      return i;\n    }\n\n    return Array.from(e);\n  }\n\n  function i(e, t) {\n    if (!e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n    return !t || \"object\" != typeof t && \"function\" != typeof t ? e : t;\n  }\n\n  function r(e, t) {\n    if (\"function\" != typeof t && null !== t) throw new TypeError(\"Super expression must either be null or a function, not \" + typeof t);\n    e.prototype = Object.create(t && t.prototype, {\n      constructor: {\n        value: e,\n        enumerable: !1,\n        writable: !0,\n        configurable: !0\n      }\n    }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);\n  }\n\n  function o(e, t) {\n    if (!(e instanceof t)) throw new TypeError(\"Cannot call a class as a function\");\n  }\n\n  function n(e, t) {\n    if (t || (t = \"undefined\" == typeof window ? global : window), void 0 !== t[e]) return t[e];\n\n    for (var i = [\"webkit\", \"moz\", \"ms\", \"o\"], r = 0, o = i.length, n = e.charAt(0).toUpperCase() + e.substr(1); r < o; r++) {\n      var a = t[i[r] + n];\n      if (void 0 !== a) return a;\n    }\n\n    return null;\n  }\n\n  function a(e, t, i, r, o, n, l) {\n    if (\"function\" != typeof r) throw new TypeError(\"Invalid animation rule:\", r);\n    var s = e - i,\n        d = s / o,\n        c = 0;\n    d > 1 && (d = 1), 1 !== d && (c = r(d), isFinite(c) && !isNaN(c) && (d = c)), t && t(d), s < o ? l.frame = ue(function (e) {\n      return a(e, t, i, r, o, n, l);\n    }) : (n && n(), l.inProgress = !1);\n  }\n\n  function l() {\n    Array.prototype.constructor.apply(this, arguments);\n  }\n\n  function s(e) {\n    if (!(e instanceof DOMException && 2152923147 === e.result)) throw e;\n  }\n\n  function d(e) {\n    return e.majorTicks instanceof Array || (e.majorTicks = e.majorTicks ? [e.majorTicks] : []), e.majorTicks.length || (e.majorTicks.push(Te.formatMajorTickNumber(e.minValue, e)), e.majorTicks.push(Te.formatMajorTickNumber(e.maxValue, e))), [\"right\" !== e.tickSide, \"left\" !== e.tickSide];\n  }\n\n  function c(e, t, i, r, o, n) {\n    e.beginPath(), e.moveTo(t + n, i), e.lineTo(t + r - n, i), e.quadraticCurveTo(t + r, i, t + r, i + n), e.lineTo(t + r, i + o - n), e.quadraticCurveTo(t + r, i + o, t + r - n, i + o), e.lineTo(t + n, i + o), e.quadraticCurveTo(t, i + o, t, i + o - n), e.lineTo(t, i + n), e.quadraticCurveTo(t, i, t + n, i), e.closePath();\n  }\n\n  function h(e, t) {\n    var i = t.valueDec,\n        r = t.valueInt,\n        o = 0,\n        n = void 0,\n        a = void 0,\n        l = void 0;\n\n    if (e = parseFloat(e), l = e < 0, e = Math.abs(e), i > 0) {\n      for (a = e.toFixed(i).toString().split(\".\"), n = r - a[0].length; o < n; ++o) {\n        a[0] = \"0\" + a[0];\n      }\n\n      a = (l ? \"-\" : \"\") + a[0] + \".\" + a[1];\n    } else {\n      for (a = Math.round(e).toString(), n = r - a.length; o < n; ++o) {\n        a = \"0\" + a;\n      }\n\n      a = (l ? \"-\" : \"\") + a;\n    }\n\n    return a;\n  }\n\n  function u(e, t) {\n    var i = void 0,\n        r = !1;\n    return i = 0 === t.majorTicksDec ? Math.round(e).toString() : e.toFixed(t.majorTicksDec), t.majorTicksInt > 1 ? (r = ~i.indexOf(\".\"), ~i.indexOf(\"-\") ? \"-\" + [t.majorTicksInt + t.majorTicksDec + 2 + (r ? 1 : 0) - i.length].join(\"0\") + i.replace(\"-\", \"\") : [t.majorTicksInt + t.majorTicksDec + 1 + (r ? 1 : 0) - i.length].join(\"0\") + i) : i;\n  }\n\n  function f(e) {\n    return e * Math.PI / 180;\n  }\n\n  function m(e, t) {\n    return {\n      x: -e * Math.sin(t),\n      y: e * Math.cos(t)\n    };\n  }\n\n  function v(e, t, i, r) {\n    var o = !(arguments.length > 4 && void 0 !== arguments[4]) || arguments[4],\n        n = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : 0,\n        a = e.createLinearGradient(o ? 0 : n, o ? n : 0, o ? 0 : r, o ? r : 0);\n    return a.addColorStop(0, t), a.addColorStop(1, i), a;\n  }\n\n  function b(e, t) {\n    if (arguments.length > 2 && void 0 !== arguments[2] && arguments[2]) return e.restore(), !0;\n    e.save();\n    var i = t.borderShadowWidth;\n    return i && (e.shadowBlur = i, e.shadowColor = t.colorBorderShadow), !0;\n  }\n\n  function g(e, t) {\n    t.needleShadow && (e.shadowOffsetX = 2, e.shadowOffsetY = 2, e.shadowBlur = 10, e.shadowColor = t.colorNeedleShadowDown);\n  }\n\n  function p(e, t, i) {\n    return e[\"font\" + t + \"Style\"] + \" \" + e[\"font\" + t + \"Weight\"] + \" \" + e[\"font\" + t + \"Size\"] * i + \"px \" + e[\"font\" + t];\n  }\n\n  function w(e) {\n    e.shadowOffsetX = null, e.shadowOffsetY = null, e.shadowBlur = null, e.shadowColor = \"\", e.strokeStyle = null, e.lineWidth = 0, e.save();\n  }\n\n  function y(e, t, i, r) {\n    t.valueTextShadow && (e.shadowOffsetX = i, e.shadowOffsetY = i, e.shadowBlur = r, e.shadowColor = t.colorValueTextShadow);\n  }\n\n  function k(e, t, i, r, o, n) {\n    if (t.valueBox) {\n      w(e);\n      var a = t.valueDec ? 1 + t.valueDec : 0,\n          l = \"9\".repeat(Math.max.apply(null, [String(parseInt(i)).length + a].concat(t.majorTicks.map(function (e) {\n        return String(parseInt(e, 10)).length + a;\n      })))),\n          s = t.valueText || h(i, t),\n          d = n / 200,\n          u = n / 100,\n          f = .4 * u,\n          m = 1.2 * u;\n      e.font = p(t, \"Value\", d), y(e, t, f, m);\n      var v = e.measureText(t.valueText ? s : \"-\" + h(Number(l), t)).width;\n      w(e);\n      var b = parseFloat(t.fontValueSize) * d + f + m,\n          g = u * parseFloat(t.valueBoxStroke),\n          k = 2 * n - 2 * g,\n          x = v + 10 * u,\n          T = 1.1 * b + f + m,\n          S = u * t.valueBoxBorderRadius,\n          W = (parseFloat(t.valueBoxWidth) || 0) / 100 * k;\n      W > x && (x = W), x > k && (x = k);\n      var O = r - x / 2,\n          V = o - T / 2,\n          P = o - 5.75 * u;\n\n      if (e.beginPath(), S ? c(e, O, V, x, T, S) : e.rect(O, V, x, T), g) {\n        var M = e.createRadialGradient(r, P, 10 * u, r, P, 20 * u);\n        M.addColorStop(0, t.colorValueBoxRect), M.addColorStop(1, t.colorValueBoxRectEnd), e.strokeStyle = M, e.lineWidth = g, e.stroke();\n      }\n\n      t.colorValueBoxShadow && (e.shadowBlur = 1.2 * u, e.shadowColor = t.colorValueBoxShadow), t.colorValueBoxBackground && (e.fillStyle = t.colorValueBoxBackground, e.fill()), e.closePath(), e.restore(), y(e, t, f, m), e.fillStyle = t.colorValueText, e.textAlign = \"center\", e.textBaseline = \"alphabetic\", e.fillText(s, O + x / 2, o + T / 2 - b / 3), e.restore();\n    }\n  }\n\n  function x(e) {\n    var t = e.value,\n        i = e.minValue,\n        r = e.maxValue,\n        o = .01 * (r - i);\n    return {\n      normal: t < i ? i : t > r ? r : t,\n      indented: t < i ? i - o : t > r ? r + o : t\n    };\n  }\n\n  function T(e, t, i, r, o) {\n    i.beginPath(), i.arc(0, 0, ye(e), 0, 2 * Se, !0), i.lineWidth = t, i.strokeStyle = o ? Te.linearGradient(i, r, o, e) : r, i.stroke(), i.closePath();\n  }\n\n  function S(e, t) {\n    var i = be.pixelRatio;\n    return e.maxRadius || (e.maxRadius = e.max - t.borderShadowWidth - t.borderOuterWidth * i - t.borderMiddleWidth * i - t.borderInnerWidth * i + (t.borderOuterWidth ? .5 : 0) + (t.borderMiddleWidth ? .5 : 0) + (t.borderInnerWidth ? .5 : 0)), e.maxRadius;\n  }\n\n  function W(e, t) {\n    var i = be.pixelRatio,\n        r = t.borderShadowWidth * i,\n        o = e.max - r - t.borderOuterWidth * i / 2,\n        n = o - t.borderOuterWidth * i / 2 - t.borderMiddleWidth * i / 2 + .5,\n        a = n - t.borderMiddleWidth * i / 2 - t.borderInnerWidth * i / 2 + .5,\n        l = S(e, t),\n        s = void 0,\n        d = !1;\n    e.save(), t.borderOuterWidth && (d = Te.drawShadow(e, t, d), T(o, t.borderOuterWidth * i, e, t.colorBorderOuter, t.colorBorderOuterEnd)), t.borderMiddleWidth && (d = Te.drawShadow(e, t, d), T(n, t.borderMiddleWidth * i, e, t.colorBorderMiddle, t.colorBorderMiddleEnd)), t.borderInnerWidth && (d = Te.drawShadow(e, t, d), T(a, t.borderInnerWidth * i, e, t.colorBorderInner, t.colorBorderInnerEnd)), Te.drawShadow(e, t, d), e.beginPath(), e.arc(0, 0, ye(l), 0, 2 * Se, !0), t.colorPlateEnd ? (s = e.createRadialGradient(0, 0, l / 2, 0, 0, l), s.addColorStop(0, t.colorPlate), s.addColorStop(1, t.colorPlateEnd)) : s = t.colorPlate, e.fillStyle = s, e.fill(), e.closePath(), e.restore();\n  }\n\n  function O(e, t) {\n    var i = e.max * (parseFloat(t.highlightsWidth) || 0) / 100;\n\n    if (i) {\n      var r = ye(P(e, t) - i / 2),\n          o = 0,\n          n = t.highlights.length,\n          a = (t.maxValue - t.minValue) / t.ticksAngle;\n\n      for (e.save(); o < n; o++) {\n        var l = t.highlights[o];\n        e.beginPath(), e.rotate(We), e.arc(0, 0, r, Te.radians(t.startAngle + (l.from - t.minValue) / a), Te.radians(t.startAngle + (l.to - t.minValue) / a), !1), e.strokeStyle = l.color, e.lineWidth = i, e.stroke(), e.closePath(), e.restore(), e.save();\n      }\n    }\n  }\n\n  function V(e, t) {\n    var i = P(e, t),\n        r = void 0,\n        o = void 0,\n        n = void 0,\n        a = 0,\n        l = 0,\n        s = Math.abs(t.minorTicks) || 0,\n        d = t.ticksAngle / (t.maxValue - t.minValue);\n\n    for (e.lineWidth = be.pixelRatio, e.strokeStyle = t.colorMinorTicks || t.colorStrokeTicks, e.save(), t.exactTicks ? (o = t.maxValue - t.minValue, r = s ? o / s : 0, l = (xe.mod(t.majorTicks[0], s) || 0) * d) : r = s * (t.majorTicks.length - 1); a < r; ++a) {\n      (n = t.startAngle + l + a * (t.ticksAngle / r)) <= t.ticksAngle + t.startAngle && (e.rotate(Te.radians(n)), e.beginPath(), e.moveTo(0, i), e.lineTo(0, i - .075 * e.max), B(e));\n    }\n  }\n\n  function P(e, t) {\n    var i = e.max / 100;\n    return S(e, t) - 5 * i - (t.barWidth ? 2 * (parseFloat(t.barStrokeWidth) || 0) + ((parseFloat(t.barWidth) || 0) + 5) * i : 0);\n  }\n\n  function M(e, t) {\n    Te.prepareTicks(t);\n    var i = ye(P(e, t)),\n        r = void 0,\n        o = void 0,\n        n = t.majorTicks.length,\n        a = be.pixelRatio;\n\n    for (e.lineWidth = 2 * a, e.save(), o = t.colorMajorTicks instanceof Array ? t.colorMajorTicks : new Array(n).fill(t.colorStrokeTicks || t.colorMajorTicks), r = 0; r < n; ++r) {\n      e.strokeStyle = o[r], e.rotate(Te.radians(A(t, t.exactTicks ? t.majorTicks[r] : r, n))), e.beginPath(), e.moveTo(0, i), e.lineTo(0, i - .15 * e.max), B(e);\n    }\n\n    t.strokeTicks && (e.strokeStyle = t.colorStrokeTicks || o[0], e.rotate(We), e.beginPath(), e.arc(0, 0, i, Te.radians(t.startAngle), Te.radians(t.startAngle + t.ticksAngle), !1), B(e));\n  }\n\n  function A(e, t, i) {\n    if (e.exactTicks) {\n      var r = e.ticksAngle / (e.maxValue - e.minValue);\n      return e.startAngle + r * (t - e.minValue);\n    }\n\n    return e.startAngle + t * (e.ticksAngle / (i - 1));\n  }\n\n  function B(e) {\n    e.stroke(), e.restore(), e.closePath(), e.save();\n  }\n\n  function j(e, t) {\n    var i = P(e, t) - .15 * e.max,\n        r = {},\n        o = 0,\n        n = t.majorTicks.length,\n        a = \"needle\" !== t.animationTarget,\n        l = t.colorNumbers instanceof Array ? t.colorNumbers : new Array(n).fill(t.colorNumbers),\n        s = a ? -(t.value - t.minValue) / (t.maxValue - t.minValue) * t.ticksAngle : 0;\n\n    for (a && (e.save(), e.rotate(-Te.radians(s))), e.font = Te.font(t, \"Numbers\", e.max / 200), e.lineWidth = 0, e.textAlign = \"center\", e.textBaseline = \"middle\"; o < n; ++o) {\n      var d = s + A(t, t.exactTicks ? t.majorTicks[o] : o, n),\n          c = e.measureText(t.majorTicks[o]).width,\n          h = t.fontNumbersSize,\n          u = Math.sqrt(c * c + h * h) / 2,\n          f = Te.radialPoint(i - u - t.numbersMargin / 100 * e.max, Te.radians(d));\n      360 === d && (d = 0), r[d] || (r[d] = !0, e.fillStyle = l[o], e.fillText(t.majorTicks[o], f.x, f.y));\n    }\n\n    a && e.restore();\n  }\n\n  function C(e, t) {\n    t.title && (e.save(), e.font = Te.font(t, \"Title\", e.max / 200), e.fillStyle = t.colorTitle, e.textAlign = \"center\", e.fillText(t.title, 0, -e.max / 4.25, .8 * e.max), e.restore());\n  }\n\n  function N(e, t) {\n    t.units && (e.save(), e.font = Te.font(t, \"Units\", e.max / 200), e.fillStyle = t.colorUnits, e.textAlign = \"center\", e.fillText(t.units, 0, e.max / 3.25, .8 * e.max), e.restore());\n  }\n\n  function E(e, t) {\n    if (t.needle) {\n      var i = t.ticksAngle < 360 ? Te.normalizedValue(t).indented : t.value,\n          r = S(e, t),\n          o = ye(r / 100 * t.needleCircleSize),\n          n = ye(r / 100 * t.needleCircleSize * .75),\n          a = ye(r / 100 * t.needleEnd),\n          l = ye(t.needleStart ? r / 100 * t.needleStart : 0),\n          s = r / 100 * t.needleWidth,\n          d = r / 100 * t.needleWidth / 2,\n          c = be.pixelRatio,\n          h = \"needle\" !== t.animationTarget;\n      e.save(), Te.drawNeedleShadow(e, t), e.rotate(Te.radians(h ? t.startAngle : t.startAngle + (i - t.minValue) / (t.maxValue - t.minValue) * t.ticksAngle)), e.fillStyle = Te.linearGradient(e, t.colorNeedle, t.colorNeedleEnd, a - l), \"arrow\" === t.needleType ? (e.beginPath(), e.moveTo(-d, -l), e.lineTo(-s, 0), e.lineTo(-1 * c, a), e.lineTo(c, a), e.lineTo(s, 0), e.lineTo(d, -l), e.closePath(), e.fill(), e.beginPath(), e.lineTo(-.5 * c, a), e.lineTo(-1 * c, a), e.lineTo(-s, 0), e.lineTo(-d, -l), e.lineTo(d / 2 * c - 2 * c, -l), e.closePath(), e.fillStyle = t.colorNeedleShadowUp, e.fill()) : (e.beginPath(), e.moveTo(-d, a), e.lineTo(-d, l), e.lineTo(d, l), e.lineTo(d, a), e.closePath(), e.fill()), t.needleCircleSize && (e.restore(), Te.drawNeedleShadow(e, t), t.needleCircleOuter && (e.beginPath(), e.arc(0, 0, o, 0, 2 * Se, !0), e.fillStyle = Te.linearGradient(e, t.colorNeedleCircleOuter, t.colorNeedleCircleOuterEnd, o), e.fill(), e.closePath()), t.needleCircleInner && (e.beginPath(), e.arc(0, 0, n, 0, 2 * Se, !0), e.fillStyle = Te.linearGradient(e, t.colorNeedleCircleInner, t.colorNeedleCircleInnerEnd, n), e.fill(), e.closePath()), e.restore());\n    }\n  }\n\n  function _(e, t, i) {\n    Te.drawValueBox(e, t, i, 0, e.max - .33 * e.max, e.max);\n  }\n\n  function R(e, t) {\n    var i = e.max / 100,\n        r = S(e, t) - 5 * i,\n        o = parseFloat(t.barStrokeWidth) || 0,\n        n = (parseFloat(t.barWidth) || 0) * i,\n        a = r - 2 * o - n,\n        l = (r - a) / 2,\n        s = a + l,\n        d = o / s,\n        c = t.startAngle,\n        h = t.startAngle + t.ticksAngle;\n    e.save(), e.rotate(We), o && (e.beginPath(), e.arc(0, 0, s, Te.radians(c) - d, Te.radians(h) + d, !1), e.strokeStyle = t.colorBarStroke, e.lineWidth = 2 * l, e.stroke(), e.closePath()), n && (e.beginPath(), e.arc(0, 0, s, Te.radians(c), Te.radians(h), !1), e.strokeStyle = t.colorBar, e.lineWidth = n, e.stroke(), e.closePath(), t.barShadow && (e.beginPath(), e.arc(0, 0, r, Te.radians(c), Te.radians(h), !1), e.clip(), e.beginPath(), e.strokeStyle = t.colorBar, e.lineWidth = 1, e.shadowBlur = t.barShadow, e.shadowColor = t.colorBarShadow, e.shadowOffsetX = 0, e.shadowOffsetY = 0, e.arc(0, 0, r, Te.radians(t.startAngle), Te.radians(t.startAngle + t.ticksAngle), !1), e.stroke(), e.closePath(), e.restore(), e.rotate(We)), t.barProgress && (e.beginPath(), e.arc(0, 0, s, Te.radians(c), Te.radians(c + (Te.normalizedValue(t).normal - t.minValue) / (t.maxValue - t.minValue) * t.ticksAngle), !1), e.strokeStyle = t.colorBarProgress, e.lineWidth = n, e.stroke(), e.closePath())), e.restore();\n  }\n\n  function I(e) {\n    return e.options.animatedValue ? e.options.value : e.value;\n  }\n\n  function D(e, t, i, r, o, n, a, l) {\n    e.beginPath(), e.fillStyle = l ? Te.linearGradient(e, a, l, o > n ? o : n, n > o, o > n ? i : r) : a, t > 0 ? Te.roundRect(e, i, r, o, n, t) : e.rect(i, r, o, n), e.fill(), e.closePath();\n  }\n\n  function z(e, t, i, r, o, n, a, l, s) {\n    e.beginPath(), e.lineWidth = t, e.strokeStyle = s ? Te.linearGradient(e, l, s, a, !0, o) : l, i > 0 ? Te.roundRect(e, r, o, n, a, i) : e.rect(r, o, n, a), e.stroke(), e.closePath();\n  }\n\n  function L(e, t, i, r, o, n) {\n    var a = be.pixelRatio;\n    e.save();\n    var l = t.borderRadius * a,\n        s = o - t.borderShadowWidth - t.borderOuterWidth * a,\n        d = s - t.borderOuterWidth * a - t.borderMiddleWidth * a,\n        c = d - t.borderMiddleWidth * a - t.borderInnerWidth * a,\n        h = c - t.borderInnerWidth * a,\n        u = n - t.borderShadowWidth - t.borderOuterWidth * a,\n        f = u - t.borderOuterWidth * a - t.borderMiddleWidth * a,\n        m = f - t.borderMiddleWidth * a - t.borderInnerWidth * a,\n        v = m - t.borderInnerWidth * a,\n        b = i - (d - s) / 2,\n        g = b - (c - d) / 2,\n        p = g - (h - c) / 2,\n        w = r - (f - u) / 2,\n        y = w - (m - f) / 2,\n        k = y - (v - m) / 2,\n        x = 0,\n        T = !1;\n    return t.borderOuterWidth && (T = Te.drawShadow(e, t, T), z(e, t.borderOuterWidth * a, l, i + t.borderOuterWidth * a / 2 - x, r + t.borderOuterWidth * a / 2 - x, s, u, t.colorBorderOuter, t.colorBorderOuterEnd), x += .5 * a), t.borderMiddleWidth && (T = Te.drawShadow(e, t, T), z(e, t.borderMiddleWidth * a, l -= 1 + 2 * x, b + t.borderMiddleWidth * a / 2 - x, w + t.borderMiddleWidth * a / 2 - x, d + 2 * x, f + 2 * x, t.colorBorderMiddle, t.colorBorderMiddleEnd), x += .5 * a), t.borderInnerWidth && (T = Te.drawShadow(e, t, T), z(e, t.borderInnerWidth * a, l -= 1 + 2 * x, g + t.borderInnerWidth * a / 2 - x, y + t.borderInnerWidth * a / 2 - x, c + 2 * x, m + 2 * x, t.colorBorderInner, t.colorBorderInnerEnd), x += .5 * a), Te.drawShadow(e, t, T), D(e, l, p, k, h + 2 * x, v + 2 * x, t.colorPlate, t.colorPlateEnd), e.restore(), [p, k, h, v];\n  }\n\n  function G(e, t, i, r, o, n) {\n    var a = be.pixelRatio,\n        l = n >= o,\n        s = l ? .85 * o : n,\n        d = l ? n : o;\n    i = l ? we(i + (o - s) / 2) : i;\n    var c = !!t.title,\n        h = !!t.units,\n        u = !!t.valueBox,\n        f = void 0,\n        m = void 0,\n        v = void 0;\n    l ? (m = we(.05 * d), f = we(.075 * d), v = we(.11 * d), c && (d -= f, r += f), h && (d -= m), u && (d -= v)) : (m = f = we(.15 * s), c && (s -= f, r += f), h && (s -= m));\n    var b = 2 * t.barStrokeWidth,\n        g = t.barBeginCircle ? we(s * t.barBeginCircle / 200 - b / 2) : 0,\n        p = we(s * t.barWidth / 100 - b),\n        w = we(d * t.barLength / 100 - b),\n        y = we((d - w) / 2),\n        k = we(i + (l ? s / 2 : y + g)),\n        x = we(r + (l ? d - y - g + b / 2 : s / 2)),\n        T = !l || t.hasLeft && t.hasRight ? 0 : (t.hasRight ? -1 : 1) * t.ticksWidth / 100 * s,\n        S = l || t.hasLeft && t.hasRight ? 0 : (t.hasRight ? -1 : 1) * t.ticksWidth / 100 * s;\n    return e.barDimensions = {\n      isVertical: l,\n      width: s,\n      length: d,\n      barWidth: p,\n      barLength: w,\n      strokeWidth: b,\n      barMargin: y,\n      radius: g,\n      pixelRatio: a,\n      barOffset: null,\n      titleMargin: c ? f : 0,\n      unitsMargin: h ? m : 0,\n\n      get ticksLength() {\n        return this.barLength - this.barOffset - this.strokeWidth;\n      },\n\n      X: i + T,\n      Y: r + S,\n      x0: k + T,\n      y0: x + S,\n      baseX: i,\n      baseY: r,\n      ticksPadding: t.ticksPadding / 100\n    }, e.barDimensions;\n  }\n\n  function F(e, t, i, r, o, n, a) {\n    var l = G(e, t, r, o, n, a),\n        s = l.isVertical,\n        d = l.width,\n        c = l.barWidth,\n        h = l.barLength,\n        u = l.strokeWidth,\n        f = l.barMargin,\n        m = l.radius,\n        v = l.x0,\n        b = l.y0,\n        g = l.X,\n        p = l.Y,\n        w = h;\n\n    if (e.save(), e.beginPath(), t.barBeginCircle) {\n      var y = Te.radians(s ? 270 : 0),\n          k = Math.asin(c / 2 / m),\n          x = Math.cos(k),\n          T = Math.sin(k),\n          S = v + (s ? m * T : m * x - u / 2),\n          W = s ? b - m * x : b + m * T,\n          O = ye(s ? W - b : S - v);\n      e.barDimensions.barOffset = we(O + m);\n      var V = s ? we(v - m * T) : S,\n          P = s ? W : we(b - m * T);\n      \"progress\" === i && (h = e.barDimensions.barOffset + (h - e.barDimensions.barOffset) * (Te.normalizedValue(t).normal - t.minValue) / (t.maxValue - t.minValue));\n      var M = we(S + h - e.barDimensions.barOffset + u / 2),\n          A = we(W - h + e.barDimensions.barOffset - u / 2);\n      e.arc(v, b, m, y + k, y - k), s ? (e.moveTo(S, P), e.lineTo(S, A), e.lineTo(V, A), e.lineTo(V, P)) : (e.moveTo(S, P), e.lineTo(M, P), e.lineTo(M, W), e.lineTo(S, W));\n    } else {\n      var B = we(s ? g + (d - c) / 2 : g + f),\n          j = we(s ? p + h + f : p + (d - c) / 2);\n      \"progress\" === i && (h *= (t.value - t.minValue) / (t.maxValue - t.minValue)), s ? e.rect(B, j, c, -h) : e.rect(B, j, h, c);\n    }\n\n    \"progress\" !== i && t.barStrokeWidth && (e.lineWidth = u, e.strokeStyle = t.colorBarStroke, e.stroke()), \"progress\" !== i && t.colorBar ? (e.fillStyle = t.colorBarEnd ? Te.linearGradient(e, t.colorBar, t.colorBarEnd, h, s, s ? p : g) : t.colorBar, e.fill()) : \"progress\" === i && t.colorBarProgress && (e.fillStyle = t.colorBarProgressEnd ? Te.linearGradient(e, t.colorBarProgress, t.colorBarProgressEnd, w, s, s ? p : g) : t.colorBarProgress, e.fill()), e.closePath(), t.barBeginCircle && (e.barDimensions.radius += u), e.barDimensions.barWidth += u, e.barDimensions.barLength += u;\n  }\n\n  function X(e, t, i, r, o, n) {\n    F(e, t, \"\", i, r, o, n);\n  }\n\n  function Y(e, t) {\n    return t.needleSide !== e || t.tickSide !== e || t.numberSide !== e;\n  }\n\n  function U(e, t, i, r, o, n) {\n    t.barProgress && F(e, t, \"progress\", i, r, o, n);\n  }\n\n  function q(e, t) {\n    var i = e.barDimensions,\n        r = i.isVertical,\n        o = i.width,\n        n = i.length,\n        a = i.barWidth,\n        l = i.barOffset,\n        s = i.barMargin,\n        d = i.X,\n        c = i.Y,\n        h = i.ticksLength,\n        u = i.ticksPadding,\n        f = o * (parseFloat(t.highlightsWidth) || 0) / 100;\n\n    if (t.highlights && f) {\n      var m = \"right\" !== t.tickSide,\n          v = \"left\" !== t.tickSide,\n          b = 0,\n          g = t.highlights.length,\n          p = (o - a) / 2,\n          w = t.maxValue - t.minValue,\n          y = we(r ? d + p : d + s + l),\n          k = f,\n          x = r ? c + n - s - l : c + p,\n          T = we((t.ticksWidth / 100 + u) * o) + (f - t.ticksWidth / 100 * o),\n          S = we(a + u * o);\n\n      for (e.save(); b < g; b++) {\n        var W = t.highlights[b],\n            O = h * ye(t.minValue - W.from) / w,\n            V = h * ye((W.to - W.from) / w);\n        e.beginPath(), e.fillStyle = W.color, r ? (m && e.rect(y - T, x - O, k, -V), v && e.rect(y + S, x - O, k, -V)) : (m && e.rect(y + O, x - T, V, k), v && e.rect(y + O, x + S, V, k)), e.fill(), e.closePath();\n      }\n    }\n  }\n\n  function H(e, t, i, r, o) {\n    e.beginPath(), e.moveTo(t, i), e.lineTo(r, o), e.stroke(), e.closePath(), e.save();\n  }\n\n  function J(e, t, i, r, o, n, a, l, s) {\n    var d = e.barDimensions,\n        c = d.isVertical,\n        h = d.length,\n        u = d.barWidth,\n        f = d.barOffset,\n        m = d.barMargin,\n        v = d.pixelRatio,\n        b = d.width,\n        g = d.X,\n        p = d.Y,\n        w = d.ticksLength,\n        y = d.ticksPadding,\n        k = (b - u) / 2,\n        x = void 0,\n        T = void 0,\n        S = 0,\n        W = i.length,\n        O = void 0,\n        V = s * b,\n        P = k - y * b,\n        M = k + u + V + y * b,\n        A = t instanceof Array ? t : new Array(i.length).fill(t);\n    e.lineWidth = l * v, e.save();\n\n    for (var B = w / (o - r); S < W; S++) {\n      O = i[S], e.strokeStyle = A[S], c ? (T = p + h - m - f + (r - O) * B, n && (x = g + P, H(e, x, T, we(x - V), T)), a && (x = g + M, H(e, x, T, we(x - V), T))) : (x = g + m + f - (r - O) * B, n && (T = p + P, H(e, x, T, x, we(T - V))), a && (T = p + M, H(e, x, we(T), x, T - V)));\n    }\n  }\n\n  function $(e, t) {\n    var i = Te.prepareTicks(t),\n        r = le(i, 2),\n        o = r[0],\n        n = r[1],\n        a = 2,\n        l = (t.maxValue - t.minValue) / (t.majorTicks.length - 1),\n        s = t.colorMajorTicks instanceof Array ? t.colorMajorTicks : new Array(t.majorTicks.length).fill(t.colorStrokeTicks || t.colorMajorTicks);\n\n    if (J(e, s, t.exactTicks ? t.majorTicks : t.majorTicks.map(function (e, i) {\n      return t.minValue + l * i;\n    }), t.minValue, t.maxValue, o, n, a, t.ticksWidth / 100), t.strokeTicks) {\n      var d = e.barDimensions,\n          c = d.isVertical,\n          h = d.length,\n          u = d.width,\n          f = d.barWidth,\n          m = d.barMargin,\n          v = d.barOffset,\n          b = d.X,\n          g = d.Y,\n          p = d.ticksLength,\n          w = d.pixelRatio,\n          y = d.ticksPadding,\n          k = (u - f) / 2 + f + y * u,\n          x = (u - f) / 2 - y * u,\n          T = void 0,\n          S = void 0,\n          W = void 0,\n          O = void 0;\n      e.strokeStyle = t.colorStrokeTicks || s[0], a *= w, c ? (S = g + h - m - v + a / 2, O = S - p - a, o && (W = T = we(b + x), Z(e, T, S, W, O)), n && (W = T = we(b + k), Z(e, T, S, W, O))) : (T = b + m + v - a / 2, W = T + p + a, o && (O = S = we(g + x), Z(e, T, S, W, O)), n && (O = S = we(g + k), Z(e, T, S, W, O)));\n    }\n  }\n\n  function Z(e, t, i, r, o) {\n    e.beginPath(), e.moveTo(t, i), e.lineTo(r, o), e.stroke(), e.closePath();\n  }\n\n  function K(e, t) {\n    var i = Te.prepareTicks(t),\n        r = le(i, 2),\n        o = r[0],\n        n = r[1],\n        a = [],\n        l = t.minValue,\n        s = Math.abs(t.minorTicks) || 0,\n        d = s ? (t.maxValue - t.minValue) / (s * (t.majorTicks.length - 1)) : 0;\n    if (s) if (t.exactTicks) for (var c = xe.mod(t.majorTicks[0], s) || 0; l < t.maxValue; l += s) {\n      c + l < t.maxValue && a.push(c + l);\n    } else for (; l < t.maxValue; l += d) {\n      a.push(l);\n    }\n    J(e, t.colorMinorTicks || t.colorStrokeTicks, a, t.minValue, t.maxValue, o, n, 1, t.ticksWidthMinor / 100);\n  }\n\n  function Q(e, t) {\n    var i = e.barDimensions,\n        r = i.isVertical,\n        o = i.length,\n        n = i.width,\n        a = i.barWidth,\n        l = i.barMargin,\n        s = i.barOffset,\n        d = i.X,\n        c = i.Y,\n        h = i.ticksLength,\n        u = i.ticksPadding,\n        f = t.maxValue - t.minValue,\n        m = f / (t.majorTicks.length - 1),\n        v = t.exactTicks ? t.majorTicks : t.majorTicks.map(function (e, i) {\n      return t.minValue + m * i;\n    }),\n        b = v.length,\n        g = \"right\" !== t.numberSide,\n        p = \"left\" !== t.numberSide,\n        w = t.fontNumbersSize * n / 200,\n        y = 0,\n        k = (t.ticksWidth / 100 + 2 * u) * n,\n        x = (n - a) / 2 - k,\n        T = (n - a) / 2 + a + k,\n        S = void 0,\n        W = void 0,\n        O = void 0,\n        V = void 0,\n        P = t.colorNumbers instanceof Array ? t.colorNumbers : new Array(b).fill(t.colorNumbers),\n        M = t.numbersMargin / 100 * n;\n\n    for (e.font = Te.font(t, \"Numbers\", n / 200), e.lineWidth = 0, e.textAlign = \"center\"; y < b; y++) {\n      e.fillStyle = P[y], V = t.majorTicks[y], O = t.exactTicks ? h * ((v[y] - t.minValue) / f) : y * h / (b - 1), r ? (W = c + o - l - s - O + w / 3, g && (e.textAlign = \"right\", e.fillText(V, d + x - M, W)), p && (e.textAlign = \"left\", e.fillText(V, d + T + M, W))) : (e.measureText(V).width, S = d + l + s + O, g && e.fillText(V, S, c + x - M), p && e.fillText(V, S, c + T + w + M));\n    }\n  }\n\n  function ee(e, t) {\n    if (t.title) {\n      var i = e.barDimensions,\n          r = i.isVertical,\n          o = i.width,\n          n = i.length,\n          a = i.baseX,\n          l = i.baseY,\n          s = i.titleMargin,\n          d = t.fontTitleSize * o / 200,\n          c = we(a + (r ? o : n) / 2),\n          h = we(l + s / 2 - (r ? d : d / 2) - .025 * (r ? n : o));\n      e.save(), e.textAlign = \"center\", e.fillStyle = t.colorTitle, e.font = Te.font(t, \"Title\", o / 200), e.lineWidth = 0, e.fillText(t.title, c, h, r ? o : n);\n    }\n  }\n\n  function te(e, t) {\n    if (t.units) {\n      var i = e.barDimensions,\n          r = i.isVertical,\n          o = i.width,\n          n = i.length,\n          a = i.baseX,\n          l = i.baseY,\n          s = i.unitsMargin,\n          d = t.fontUnitsSize * o / 200,\n          c = we(a + (r ? o : n) / 2),\n          h = we(l + (r ? n : o) + s / 2 - d / 2);\n      e.save(), e.textAlign = \"center\", e.fillStyle = t.colorUnits, e.font = Te.font(t, \"Units\", o / 200), e.lineWidth = 0, e.fillText(t.units, c, h, r ? o : n);\n    }\n  }\n\n  function ie(e, t) {\n    if (t.needle) {\n      var i = e.barDimensions,\n          r = i.isVertical,\n          o = i.width,\n          n = i.length,\n          a = i.barWidth,\n          l = i.barOffset,\n          s = i.barMargin,\n          d = i.ticksLength,\n          c = i.X,\n          h = i.Y,\n          u = i.ticksPadding,\n          f = \"right\" !== t.needleSide,\n          m = \"left\" !== t.needleSide,\n          v = d * (Te.normalizedValue(t).indented - t.minValue) / (t.maxValue - t.minValue),\n          b = (t.ticksWidth / 100 + u) * o,\n          g = a / 2 + b,\n          p = g * (t.needleEnd / 100),\n          w = void 0,\n          y = void 0,\n          k = void 0,\n          x = void 0,\n          T = \"arrow\" === t.needleType.toLowerCase() ? ne : oe,\n          S = (o - a) / 2,\n          W = g * (t.needleStart / 100),\n          O = S - b - W,\n          V = S + a + b + W;\n      e.save(), Te.drawNeedleShadow(e, t), r ? (k = we(h + n - s - l - v), f && (w = we(c + O), y = w + p, T(e, t, w, k, y, k, p)), m && (w = we(c + V), y = w - p, T(e, t, w, k, y, k, p, !0))) : (w = we(c + s + l + v), f && (k = we(h + O), x = k + p, T(e, t, w, k, w, x, p)), m && (k = we(h + V), x = k - p, T(e, t, w, k, w, x, p, !0))), e.restore();\n    }\n  }\n\n  function re(e, t, i, r) {\n    return t.colorNeedleEnd ? Te.linearGradient(e, r ? t.colorNeedleEnd : t.colorNeedle, r ? t.colorNeedle : t.colorNeedleEnd, i, !e.barDimensions.isVertical) : t.colorNeedle;\n  }\n\n  function oe(e, t, i, r, o, n, a, l) {\n    e.lineWidth = t.needleWidth, e.strokeStyle = re(e, t, a, l), e.beginPath(), e.moveTo(i, r), e.lineTo(o, n), e.stroke(), e.closePath();\n  }\n\n  function ne(e, t, i, r, o, n, a, l) {\n    var s = we(.4 * a),\n        d = a - s,\n        c = i === o,\n        h = t.needleWidth / 2;\n    e.fillStyle = re(e, t, a, l), e.beginPath(), c ? (r > n && (d *= -1), e.moveTo(i - h, r), e.lineTo(i + h, r), e.lineTo(i + h, r + d), e.lineTo(i, n), e.lineTo(i - h, r + d), e.lineTo(i - h, r)) : (i > o && (d *= -1), e.moveTo(i, r - h), e.lineTo(i, r + h), e.lineTo(i + d, r + h), e.lineTo(o, r), e.lineTo(i + d, r - h), e.lineTo(i, r - h)), e.fill(), e.closePath();\n  }\n\n  function ae(e, t, i, r, o, n, a) {\n    var l = (parseFloat(t.fontValueSize) || 0) * n / 200,\n        s = (.11 * a - l) / 2;\n    e.barDimensions.isVertical && Te.drawValueBox(e, t, i, r + n / 2, o + a - l - s, n);\n  }\n\n  var le = function () {\n    function e(e, t) {\n      var i = [],\n          r = !0,\n          o = !1,\n          n = void 0;\n\n      try {\n        for (var a, l = e[Symbol.iterator](); !(r = (a = l.next()).done) && (i.push(a.value), !t || i.length !== t); r = !0) {\n          ;\n        }\n      } catch (e) {\n        o = !0, n = e;\n      } finally {\n        try {\n          !r && l.return && l.return();\n        } finally {\n          if (o) throw n;\n        }\n      }\n\n      return i;\n    }\n\n    return function (t, i) {\n      if (Array.isArray(t)) return t;\n      if (Symbol.iterator in Object(t)) return e(t, i);\n      throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n    };\n  }(),\n      se = function e(t, i, r) {\n    null === t && (t = Function.prototype);\n    var o = Object.getOwnPropertyDescriptor(t, i);\n\n    if (void 0 === o) {\n      var n = Object.getPrototypeOf(t);\n      return null === n ? void 0 : e(n, i, r);\n    }\n\n    if (\"value\" in o) return o.value;\n    var a = o.get;\n    if (void 0 !== a) return a.call(r);\n  },\n      de = function e(t, i, r, o) {\n    var n = Object.getOwnPropertyDescriptor(t, i);\n\n    if (void 0 === n) {\n      var a = Object.getPrototypeOf(t);\n      null !== a && e(a, i, r, o);\n    } else if (\"value\" in n && n.writable) n.value = r;else {\n      var l = n.set;\n      void 0 !== l && l.call(o, r);\n    }\n\n    return r;\n  },\n      ce = function () {\n    function e(e, t) {\n      for (var i = 0; i < t.length; i++) {\n        var r = t[i];\n        r.enumerable = r.enumerable || !1, r.configurable = !0, \"value\" in r && (r.writable = !0), Object.defineProperty(e, r.key, r);\n      }\n    }\n\n    return function (t, i, r) {\n      return i && e(t.prototype, i), r && e(t, r), t;\n    };\n  }();\n\n  Object.assign || Object.defineProperty(Object, \"assign\", {\n    enumerable: !1,\n    configurable: !0,\n    writable: !0,\n    value: function value(e, t) {\n      if (void 0 === e || null === e) throw new TypeError(\"Cannot convert first argument to object\");\n\n      for (var i = Object(e), r = 1; r < arguments.length; r++) {\n        var o = arguments[r];\n        if (void 0 !== o && null !== o) for (var n = Object.keys(Object(o)), a = 0, l = n.length; a < l; a++) {\n          var s = n[a],\n              d = Object.getOwnPropertyDescriptor(o, s);\n          void 0 !== d && d.enumerable && (i[s] = o[s]);\n        }\n      }\n\n      return i;\n    }\n  }), Array.prototype.indexOf || Object.defineProperty(Array.prototype, \"indexOf\", {\n    value: function value(e, t) {\n      var i;\n      if (null === this) throw new TypeError('\"this\" is null or not defined');\n      var r = Object(this),\n          o = r.length >>> 0;\n      if (0 === o) return -1;\n      var n = +t || 0;\n      if (Math.abs(n) === 1 / 0 && (n = 0), n >= o) return -1;\n\n      for (i = Math.max(n >= 0 ? n : o - Math.abs(n), 0); i < o;) {\n        if (i in r && r[i] === e) return i;\n        i++;\n      }\n\n      return -1;\n    }\n  }), Array.prototype.fill || Object.defineProperty(Array.prototype, \"fill\", {\n    value: function value(e) {\n      if (null === this) throw new TypeError(\"this is null or not defined\");\n\n      for (var t = Object(this), i = t.length >>> 0, r = arguments[1], o = r >> 0, n = o < 0 ? Math.max(i + o, 0) : Math.min(o, i), a = arguments[2], l = void 0 === a ? i : a >> 0, s = l < 0 ? Math.max(i + l, 0) : Math.min(l, i); n < s;) {\n        t[n] = e, n++;\n      }\n\n      return t;\n    }\n  }), \"undefined\" == typeof window && (window = \"undefined\" == typeof global ? {} : global);\n\n  var he = function () {\n    function e() {\n      o(this, e), this._events = {}, this.addListener = this.on, this.removeListener = this.off;\n    }\n\n    return ce(e, [{\n      key: \"emit\",\n      value: function value(e) {\n        if (this._events[e]) {\n          for (var t = 0, i = this._events[e].length, r = arguments.length, o = Array(r > 1 ? r - 1 : 0), n = 1; n < r; n++) {\n            o[n - 1] = arguments[n];\n          }\n\n          for (; t < i; t++) {\n            this._events[e][t] && this._events[e][t].apply(this, o);\n          }\n        }\n      }\n    }, {\n      key: \"once\",\n      value: function value(e) {\n        for (var t = arguments.length, i = Array(t > 1 ? t - 1 : 0), r = 1; r < t; r++) {\n          i[r - 1] = arguments[r];\n        }\n\n        for (var o = 0, n = i.length, a = this; o < n; o++) {\n          !function () {\n            var t = i[o],\n                r = function i() {\n              a.off(e, i), t.apply(a, arguments);\n            };\n\n            i[o] = r;\n          }();\n        }\n\n        this.on.apply(this, [e].concat(i));\n      }\n    }, {\n      key: \"on\",\n      value: function value(e) {\n        this._events[e] || (this._events[e] = []);\n\n        for (var t = 0, i = arguments.length <= 1 ? 0 : arguments.length - 1; t < i; t++) {\n          this._events[e].push(arguments.length <= t + 1 ? void 0 : arguments[t + 1]);\n        }\n      }\n    }, {\n      key: \"off\",\n      value: function value(e) {\n        if (this._events[e]) for (var t = 0, i = arguments.length <= 1 ? 0 : arguments.length - 1; t < i; t++) {\n          for (var r = arguments.length <= t + 1 ? void 0 : arguments[t + 1], o = void 0; ~(o = this._events[e].indexOf(r));) {\n            this._events[e].splice(o, 1);\n          }\n        }\n      }\n    }, {\n      key: \"removeAllListeners\",\n      value: function value(e) {\n        delete this._events[e];\n      }\n    }, {\n      key: \"listeners\",\n      get: function get() {\n        return this._events;\n      }\n    }]), e;\n  }(),\n      ue = n(\"requestAnimationFrame\") || function (e) {\n    return setTimeout(function () {\n      return e(new Date().getTime());\n    }, 1e3 / 60);\n  },\n      fe = {\n    linear: function linear(e) {\n      return e;\n    },\n    quad: function quad(e) {\n      return Math.pow(e, 2);\n    },\n    dequad: function dequad(e) {\n      return 1 - fe.quad(1 - e);\n    },\n    quint: function quint(e) {\n      return Math.pow(e, 5);\n    },\n    dequint: function dequint(e) {\n      return 1 - Math.pow(1 - e, 5);\n    },\n    cycle: function cycle(e) {\n      return 1 - Math.sin(Math.acos(e));\n    },\n    decycle: function decycle(e) {\n      return Math.sin(Math.acos(1 - e));\n    },\n    bounce: function bounce(e) {\n      return 1 - fe.debounce(1 - e);\n    },\n    debounce: function debounce(e) {\n      for (var t = 0, i = 1; 1; t += i, i /= 2) {\n        if (e >= (7 - 4 * t) / 11) return -Math.pow((11 - 6 * t - 11 * e) / 4, 2) + Math.pow(i, 2);\n      }\n    },\n    elastic: function elastic(e) {\n      return 1 - fe.delastic(1 - e);\n    },\n    delastic: function delastic(e) {\n      return Math.pow(2, 10 * (e - 1)) * Math.cos(20 * Math.PI * 1.5 / 3 * e);\n    }\n  },\n      me = function () {\n    function e() {\n      var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : \"linear\",\n          i = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 250,\n          r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : function () {},\n          n = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : function () {};\n      if (o(this, e), this.duration = i, this.rule = t, this.draw = r, this.end = n, \"function\" != typeof this.draw) throw new TypeError(\"Invalid animation draw callback:\", r);\n      if (\"function\" != typeof this.end) throw new TypeError(\"Invalid animation end callback:\", n);\n    }\n\n    return ce(e, [{\n      key: \"animate\",\n      value: function value(e, t) {\n        var i = this;\n        this.frame && this.cancel();\n        var r = window.performance && window.performance.now ? window.performance.now() : n(\"animationStartTime\") || Date.now();\n        e = e || this.draw, t = t || this.end, this.draw = e, this.end = t, this.frame = ue(function (o) {\n          return a(o, e, r, fe[i.rule] || i.rule, i.duration, t, i);\n        });\n      }\n    }, {\n      key: \"cancel\",\n      value: function value() {\n        if (this.frame) {\n          (n(\"cancelAnimationFrame\") || function (e) {})(this.frame), this.frame = null;\n        }\n      }\n    }, {\n      key: \"destroy\",\n      value: function value() {\n        this.cancel(), this.draw = null, this.end = null;\n      }\n    }]), e;\n  }();\n\n  me.rules = fe;\n\n  var ve = function () {\n    function t(i, r, n) {\n      o(this, t), this.options = i, this.element = r.toLowerCase(), this.type = t.toDashed(n), this.Type = e[n], this.mutationsObserved = !1, this.isObservable = !!window.MutationObserver, window.GAUGES_NO_AUTO_INIT || t.domReady(this.traverse.bind(this));\n    }\n\n    return ce(t, [{\n      key: \"isValidNode\",\n      value: function value(e) {\n        return !(!e.tagName || e.tagName.toLowerCase() !== this.element || e.getAttribute(\"data-type\") !== this.type);\n      }\n    }, {\n      key: \"traverse\",\n      value: function value() {\n        for (var e = document.getElementsByTagName(this.element), t = 0, i = e.length; t < i; t++) {\n          this.process(e[t]);\n        }\n\n        this.isObservable && !this.mutationsObserved && (new MutationObserver(this.observe.bind(this)).observe(document.body, {\n          childList: !0,\n          subtree: !0,\n          attributes: !0,\n          characterData: !0,\n          attributeOldValue: !0,\n          characterDataOldValue: !0\n        }), this.mutationsObserved = !0);\n      }\n    }, {\n      key: \"observe\",\n      value: function value(e) {\n        for (var t = 0, i = e.length; t < i; t++) {\n          var r = e[t];\n          if (\"attributes\" === r.type && \"data-type\" === r.attributeName && this.isValidNode(r.target) && r.oldValue !== this.type) setTimeout(this.process.bind(this, r.target));else if (r.addedNodes && r.addedNodes.length) for (var o = 0, n = r.addedNodes.length; o < n; o++) {\n            setTimeout(this.process.bind(this, r.addedNodes[o]));\n          }\n        }\n      }\n    }, {\n      key: \"process\",\n      value: function value(e) {\n        var i = this;\n        if (!this.isValidNode(e)) return null;\n        var r = void 0,\n            o = JSON.parse(JSON.stringify(this.options)),\n            n = null;\n\n        for (r in o) {\n          if (o.hasOwnProperty(r)) {\n            var a = t.toAttributeName(r),\n                l = t.parse(e.getAttribute(a));\n            null !== l && void 0 !== l && (o[r] = l);\n          }\n        }\n\n        return o.renderTo = e, n = new this.Type(o), n.draw && n.draw(), this.isObservable ? (n.observer = new MutationObserver(function (r) {\n          r.forEach(function (r) {\n            if (\"attributes\" === r.type) {\n              var o = r.attributeName.toLowerCase(),\n                  a = e.getAttribute(o).toLowerCase();\n              if (\"data-type\" === o && a && a !== i.type) n.observer.disconnect(), delete n.observer, n.destroy && n.destroy();else if (\"data-\" === o.substr(0, 5)) {\n                var l = o.substr(5).split(\"-\").map(function (e, t) {\n                  return t ? e.charAt(0).toUpperCase() + e.substr(1) : e;\n                }).join(\"\"),\n                    s = {};\n                s[l] = t.parse(e.getAttribute(r.attributeName)), \"value\" === l ? n && (n.value = s[l]) : n.update && n.update(s);\n              }\n            }\n          });\n        }), n.observer.observe(e, {\n          attributes: !0\n        }), n) : n;\n      }\n    }], [{\n      key: \"parse\",\n      value: function value(e) {\n        if (\"true\" === e) return !0;\n        if (\"false\" === e) return !1;\n\n        if (\"undefined\" !== e) {\n          if (\"null\" === e) return null;\n          if (/^[-+#.\\w\\d\\s]+(?:,[-+#.\\w\\d\\s]*)+$/.test(e)) return e.split(\",\");\n\n          try {\n            return JSON.parse(e);\n          } catch (e) {}\n\n          return e;\n        }\n      }\n    }, {\n      key: \"toDashed\",\n      value: function value(e) {\n        for (var t = e.split(/(?=[A-Z])/), i = 1, r = t.length, o = t[0].toLowerCase(); i < r; i++) {\n          o += \"-\" + t[i].toLowerCase();\n        }\n\n        return o;\n      }\n    }, {\n      key: \"toCamelCase\",\n      value: function value(e) {\n        for (var t = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1], i = e.split(/-/), r = 0, o = i.length, n = \"\"; r < o; r++) {\n          n += r || t ? i[r][0].toUpperCase() + i[r].substr(1).toLowerCase() : i[r].toLowerCase();\n        }\n\n        return n;\n      }\n    }, {\n      key: \"toAttributeName\",\n      value: function value(e) {\n        return \"data-\" + t.toDashed(e);\n      }\n    }, {\n      key: \"domReady\",\n      value: function value(e) {\n        if (/comp|inter|loaded/.test((window.document || {}).readyState + \"\")) return e();\n        window.addEventListener ? window.addEventListener(\"DOMContentLoaded\", e, !1) : window.attachEvent && window.attachEvent(\"onload\", e);\n      }\n    }]), t;\n  }(),\n      be = function () {\n    function e(t, i, r) {\n      o(this, e), e.collection.push(this), this.width = i || 0, this.height = r || 0, this.element = t, this.init();\n    }\n\n    return ce(e, [{\n      key: \"init\",\n      value: function value() {\n        var t = e.pixelRatio;\n        this.element.width = this.width * t, this.element.height = this.height * t, this.element.style.width = this.width + \"px\", this.element.style.height = this.height + \"px\", this.elementClone = this.element.cloneNode(!0), this.context = this.element.getContext(\"2d\"), this.contextClone = this.elementClone.getContext(\"2d\"), this.drawWidth = this.element.width, this.drawHeight = this.element.height, this.drawX = this.drawWidth / 2, this.drawY = this.drawHeight / 2, this.minSide = this.drawX < this.drawY ? this.drawX : this.drawY, this.elementClone.initialized = !1, this.contextClone.translate(this.drawX, this.drawY), this.contextClone.save(), this.context.translate(this.drawX, this.drawY), this.context.save(), this.context.max = this.contextClone.max = this.minSide, this.context.maxRadius = this.contextClone.maxRadius = null;\n      }\n    }, {\n      key: \"destroy\",\n      value: function value() {\n        var t = e.collection.indexOf(this);\n        ~t && e.collection.splice(t, 1), this.context.clearRect(-this.drawX, -this.drawY, this.drawWidth, this.drawHeight), this.context.max = null, delete this.context.max, this.context.maxRadius = null, delete this.context.maxRadius, this.context = null, this.contextClone = null, this.elementClone = null, this.element = null, this.onRedraw = null;\n      }\n    }, {\n      key: \"commit\",\n      value: function value() {\n        var t = e.pixelRatio;\n        return 1 !== t && (this.contextClone.scale(t, t), this.contextClone.save()), this;\n      }\n    }, {\n      key: \"redraw\",\n      value: function value() {\n        return this.init(), this.onRedraw && this.onRedraw(), this;\n      }\n    }], [{\n      key: \"redraw\",\n      value: function value() {\n        for (var t = 0, i = e.collection.length; t < i; t++) {\n          e.collection[t].redraw();\n        }\n      }\n    }, {\n      key: \"pixelRatio\",\n      get: function get() {\n        return window.devicePixelRatio || 1;\n      }\n    }]), e;\n  }();\n\n  be.collection = [], window.matchMedia && window.matchMedia(\"screen and (min-resolution: 2dppx)\").addListener(be.redraw);\n  var ge = {\n    renderTo: null,\n    width: 0,\n    height: 0,\n    minValue: 0,\n    maxValue: 100,\n    value: 0,\n    units: !1,\n    exactTicks: !1,\n    majorTicks: [0, 20, 40, 60, 80, 100],\n    minorTicks: 10,\n    strokeTicks: !0,\n    animatedValue: !1,\n    animateOnInit: !1,\n    title: !1,\n    borders: !0,\n    numbersMargin: 1,\n    listeners: null,\n    valueInt: 3,\n    valueDec: 2,\n    majorTicksInt: 1,\n    majorTicksDec: 0,\n    animation: !0,\n    animationDuration: 500,\n    animationRule: \"cycle\",\n    colorPlate: \"#fff\",\n    colorPlateEnd: \"\",\n    colorMajorTicks: \"#444\",\n    colorMinorTicks: \"#666\",\n    colorStrokeTicks: \"\",\n    colorTitle: \"#888\",\n    colorUnits: \"#888\",\n    colorNumbers: \"#444\",\n    colorNeedle: \"rgba(240,128,128,1)\",\n    colorNeedleEnd: \"rgba(255,160,122,.9)\",\n    colorValueText: \"#444\",\n    colorValueTextShadow: \"rgba(0,0,0,0.3)\",\n    colorBorderShadow: \"rgba(0,0,0,0.5)\",\n    colorBorderOuter: \"#ddd\",\n    colorBorderOuterEnd: \"#aaa\",\n    colorBorderMiddle: \"#eee\",\n    colorBorderMiddleEnd: \"#f0f0f0\",\n    colorBorderInner: \"#fafafa\",\n    colorBorderInnerEnd: \"#ccc\",\n    colorValueBoxRect: \"#888\",\n    colorValueBoxRectEnd: \"#666\",\n    colorValueBoxBackground: \"#babab2\",\n    colorValueBoxShadow: \"rgba(0,0,0,1)\",\n    colorNeedleShadowUp: \"rgba(2,255,255,0.2)\",\n    colorNeedleShadowDown: \"rgba(188,143,143,0.45)\",\n    colorBarStroke: \"#222\",\n    colorBar: \"#ccc\",\n    colorBarProgress: \"#888\",\n    colorBarShadow: \"#000\",\n    fontNumbers: \"Arial\",\n    fontTitle: \"Arial\",\n    fontUnits: \"Arial\",\n    fontValue: \"Arial\",\n    fontNumbersSize: 20,\n    fontTitleSize: 24,\n    fontUnitsSize: 22,\n    fontValueSize: 26,\n    fontNumbersStyle: \"normal\",\n    fontTitleStyle: \"normal\",\n    fontUnitsStyle: \"normal\",\n    fontValueStyle: \"normal\",\n    fontNumbersWeight: \"normal\",\n    fontTitleWeight: \"normal\",\n    fontUnitsWeight: \"normal\",\n    fontValueWeight: \"normal\",\n    needle: !0,\n    needleShadow: !0,\n    needleType: \"arrow\",\n    needleStart: 5,\n    needleEnd: 85,\n    needleWidth: 4,\n    borderOuterWidth: 3,\n    borderMiddleWidth: 3,\n    borderInnerWidth: 3,\n    borderShadowWidth: 3,\n    valueBox: !0,\n    valueBoxStroke: 5,\n    valueBoxWidth: 0,\n    valueText: \"\",\n    valueTextShadow: !0,\n    valueBoxBorderRadius: 2.5,\n    highlights: [{\n      from: 20,\n      to: 60,\n      color: \"#eee\"\n    }, {\n      from: 60,\n      to: 80,\n      color: \"#ccc\"\n    }, {\n      from: 80,\n      to: 100,\n      color: \"#999\"\n    }],\n    highlightsWidth: 15,\n    barWidth: 20,\n    barStrokeWidth: 0,\n    barProgress: !0,\n    barShadow: 0\n  };\n  l.prototype = Object.create(Array.prototype), l.prototype.constructor = l, l.prototype.get = function (e) {\n    if (\"string\" == typeof e) for (var t = 0, i = this.length; t < i; t++) {\n      var r = this[t].options.renderTo.tagName ? this[t].options.renderTo : document.getElementById(this[t].options.renderTo || \"\");\n      if (r.getAttribute(\"id\") === e) return this[t];\n    } else if (\"number\" == typeof e) return this[e];\n    return null;\n  };\n  var pe = \"2.1.5\",\n      we = Math.round,\n      ye = Math.abs,\n      ke = new l();\n  ke.version = pe;\n\n  var xe = function (t) {\n    function n(t) {\n      o(this, n);\n      var r = i(this, (n.__proto__ || Object.getPrototypeOf(n)).call(this)),\n          a = r.constructor.name;\n      if (\"BaseGauge\" === a) throw new TypeError(\"Attempt to instantiate abstract class!\");\n      if (ke.push(r), t.listeners && Object.keys(t.listeners).forEach(function (e) {\n        (t.listeners[e] instanceof Array ? t.listeners[e] : [t.listeners[e]]).forEach(function (t) {\n          r.on(e, t);\n        });\n      }), r.version = pe, r.type = e[a] || n, r.initialized = !1, t.minValue = parseFloat(t.minValue), t.maxValue = parseFloat(t.maxValue), t.value = parseFloat(t.value) || 0, t.borders || (t.borderInnerWidth = t.borderMiddleWidth = t.borderOuterWidth = 0), !t.renderTo) throw TypeError(\"Canvas element was not specified when creating the Gauge object!\");\n      var l = t.renderTo.tagName ? t.renderTo : document.getElementById(t.renderTo);\n      if (!(l instanceof HTMLCanvasElement)) throw TypeError(\"Given gauge canvas element is invalid!\");\n      return t.width = parseFloat(t.width) || 0, t.height = parseFloat(t.height) || 0, t.width && t.height || (t.width || (t.width = l.parentNode ? l.parentNode.offsetWidth : l.offsetWidth), t.height || (t.height = l.parentNode ? l.parentNode.offsetHeight : l.offsetHeight)), r.options = t || {}, r.options.animateOnInit && (r._value = r.options.value, r.options.value = r.options.minValue), r.canvas = new be(l, t.width, t.height), r.canvas.onRedraw = r.draw.bind(r), r.animation = new me(t.animationRule, t.animationDuration), r;\n    }\n\n    return r(n, t), ce(n, [{\n      key: \"update\",\n      value: function value(e) {\n        return Object.assign(this.options, this.type.configure(e || {})), this.canvas.width = this.options.width, this.canvas.height = this.options.height, this.animation.rule = this.options.animationRule, this.animation.duration = this.options.animationDuration, this.canvas.redraw(), this;\n      }\n    }, {\n      key: \"destroy\",\n      value: function value() {\n        var e = ke.indexOf(this);\n        ~e && ke.splice(e, 1), this.canvas.destroy(), this.canvas = null, this.animation.destroy(), this.animation = null, this.emit(\"destroy\");\n      }\n    }, {\n      key: \"draw\",\n      value: function value() {\n        return this.options.animateOnInit && !this.initialized && (this.value = this._value, this.initialized = !0, this.emit(\"init\")), this.emit(\"render\"), this;\n      }\n    }, {\n      key: \"value\",\n      set: function set(e) {\n        var t = this;\n        e = n.ensureValue(e, this.options.minValue);\n        var i = this.options.value;\n        if (e !== i) if (this.options.animation) {\n          if (this.animation.frame && (this.options.value = this._value, this._value === e)) return this.animation.cancel(), void delete this._value;\n          void 0 === this._value && (this._value = e), this.emit(\"animationStart\"), this.animation.animate(function (r) {\n            var o = i + (e - i) * r;\n            t.options.animatedValue && t.emit(\"value\", o, t.value), t.options.value = o, t.draw(), t.emit(\"animate\", r, t.options.value);\n          }, function () {\n            void 0 !== t._value && (t.emit(\"value\", t._value, t.value), t.options.value = t._value, delete t._value), t.draw(), t.emit(\"animationEnd\");\n          });\n        } else this.emit(\"value\", e, this.value), this.options.value = e, this.draw();\n      },\n      get: function get() {\n        return void 0 === this._value ? this.options.value : this._value;\n      }\n    }], [{\n      key: \"configure\",\n      value: function value(e) {\n        return e;\n      }\n    }, {\n      key: \"initialize\",\n      value: function value(e, t) {\n        return new ve(t, \"canvas\", e);\n      }\n    }, {\n      key: \"fromElement\",\n      value: function value(e) {\n        var t = ve.toCamelCase(e.getAttribute(\"data-type\")),\n            i = e.attributes,\n            r = 0,\n            o = i.length,\n            n = {};\n\n        if (t) {\n          for (/Gauge$/.test(t) || (t += \"Gauge\"); r < o; r++) {\n            n[ve.toCamelCase(i[r].name.replace(/^data-/, \"\"), !1)] = ve.parse(i[r].value);\n          }\n\n          new ve(n, e.tagName, t).process(e);\n        }\n      }\n    }, {\n      key: \"ensureValue\",\n      value: function value(e) {\n        var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;\n        return e = parseFloat(e), !isNaN(e) && isFinite(e) || (e = parseFloat(t) || 0), e;\n      }\n    }, {\n      key: \"mod\",\n      value: function value(e, t) {\n        return (e % t + t) % t;\n      }\n    }, {\n      key: \"version\",\n      get: function get() {\n        return pe;\n      }\n    }]), n;\n  }(he);\n\n  void 0 !== e && (e.BaseGauge = xe, e.gauges = (window.document || {}).gauges = ke);\n\n  var Te = {\n    roundRect: c,\n    padValue: h,\n    formatMajorTickNumber: u,\n    radians: f,\n    radialPoint: m,\n    linearGradient: v,\n    drawNeedleShadow: g,\n    drawValueBox: k,\n    verifyError: s,\n    prepareTicks: d,\n    drawShadow: b,\n    font: p,\n    normalizedValue: x\n  },\n      Se = Math.PI,\n      We = Se / 2,\n      Oe = Object.assign({}, ge, {\n    ticksAngle: 270,\n    startAngle: 45,\n    colorNeedleCircleOuter: \"#f0f0f0\",\n    colorNeedleCircleOuterEnd: \"#ccc\",\n    colorNeedleCircleInner: \"#e8e8e8\",\n    colorNeedleCircleInnerEnd: \"#f5f5f5\",\n    needleCircleSize: 10,\n    needleCircleInner: !0,\n    needleCircleOuter: !0,\n    needleStart: 20,\n    animationTarget: \"needle\",\n    useMinPath: !1,\n    barWidth: 0\n  }),\n      Ve = function (e) {\n    function t(e) {\n      return o(this, t), e = Object.assign({}, Oe, e || {}), i(this, (t.__proto__ || Object.getPrototypeOf(t)).call(this, t.configure(e)));\n    }\n\n    return r(t, e), ce(t, [{\n      key: \"draw\",\n      value: function value() {\n        try {\n          var e = this.canvas,\n              i = [-e.drawX, -e.drawY, e.drawWidth, e.drawHeight],\n              r = i[0],\n              o = i[1],\n              n = i[2],\n              a = i[3],\n              l = this.options;\n\n          if (\"needle\" === l.animationTarget) {\n            if (!e.elementClone.initialized) {\n              var s = e.contextClone;\n              s.clearRect(r, o, n, a), s.save(), this.emit(\"beforePlate\"), W(s, l), this.emit(\"beforeHighlights\"), O(s, l), this.emit(\"beforeMinorTicks\"), V(s, l), this.emit(\"beforeMajorTicks\"), M(s, l), this.emit(\"beforeNumbers\"), j(s, l), this.emit(\"beforeTitle\"), C(s, l), this.emit(\"beforeUnits\"), N(s, l), e.elementClone.initialized = !0;\n            }\n\n            this.canvas.commit(), e.context.clearRect(r, o, n, a), e.context.save(), e.context.drawImage(e.elementClone, r, o, n, a), e.context.save(), this.emit(\"beforeProgressBar\"), R(e.context, l), this.emit(\"beforeValueBox\"), _(e.context, l, I(this)), this.emit(\"beforeNeedle\"), E(e.context, l);\n          } else {\n            var d = -Te.radians((l.value - l.minValue) / (l.maxValue - l.minValue) * l.ticksAngle);\n\n            if (e.context.clearRect(r, o, n, a), e.context.save(), this.emit(\"beforePlate\"), W(e.context, l), e.context.rotate(d), this.emit(\"beforeHighlights\"), O(e.context, l), this.emit(\"beforeMinorTicks\"), V(e.context, l), this.emit(\"beforeMajorTicks\"), M(e.context, l), this.emit(\"beforeNumbers\"), j(e.context, l), this.emit(\"beforeProgressBar\"), R(e.context, l), e.context.rotate(-d), e.context.save(), !e.elementClone.initialized) {\n              var c = e.contextClone;\n              c.clearRect(r, o, n, a), c.save(), this.emit(\"beforeTitle\"), C(c, l), this.emit(\"beforeUnits\"), N(c, l), this.emit(\"beforeNeedle\"), E(c, l), e.elementClone.initialized = !0;\n            }\n\n            e.context.drawImage(e.elementClone, r, o, n, a);\n          }\n\n          this.emit(\"beforeValueBox\"), _(e.context, l, I(this)), se(t.prototype.__proto__ || Object.getPrototypeOf(t.prototype), \"draw\", this).call(this);\n        } catch (e) {\n          Te.verifyError(e);\n        }\n\n        return this;\n      }\n    }, {\n      key: \"value\",\n      set: function set(e) {\n        e = xe.ensureValue(e, this.options.minValue), this.options.animation && 360 === this.options.ticksAngle && this.options.useMinPath && (this._value = e, e = this.options.value + ((e - this.options.value) % 360 + 540) % 360 - 180), de(t.prototype.__proto__ || Object.getPrototypeOf(t.prototype), \"value\", e, this);\n      },\n      get: function get() {\n        return se(t.prototype.__proto__ || Object.getPrototypeOf(t.prototype), \"value\", this);\n      }\n    }], [{\n      key: \"configure\",\n      value: function value(e) {\n        return e.barWidth > 50 && (e.barWidth = 50), isNaN(e.startAngle) && (e.startAngle = 45), isNaN(e.ticksAngle) && (e.ticksAngle = 270), e.ticksAngle > 360 && (e.ticksAngle = 360), e.ticksAngle < 0 && (e.ticksAngle = 0), e.startAngle < 0 && (e.startAngle = 0), e.startAngle > 360 && (e.startAngle = 360), e;\n      }\n    }]), t;\n  }(xe);\n\n  void 0 !== e && (e.RadialGauge = Ve), xe.initialize(\"RadialGauge\", Oe);\n\n  var Pe = Object.assign({}, ge, {\n    borderRadius: 0,\n    barBeginCircle: 30,\n    colorBarEnd: \"\",\n    colorBarProgressEnd: \"\",\n    needleWidth: 6,\n    tickSide: \"both\",\n    needleSide: \"both\",\n    numberSide: \"both\",\n    ticksWidth: 10,\n    ticksWidthMinor: 5,\n    ticksPadding: 5,\n    barLength: 85,\n    fontTitleSize: 26,\n    highlightsWidth: 10\n  }),\n      Me = function (e) {\n    function n(e) {\n      return o(this, n), e = Object.assign({}, Pe, e || {}), i(this, (n.__proto__ || Object.getPrototypeOf(n)).call(this, n.configure(e)));\n    }\n\n    return r(n, e), ce(n, [{\n      key: \"draw\",\n      value: function value() {\n        try {\n          var e = this.canvas,\n              i = [-e.drawX, -e.drawY, e.drawWidth, e.drawHeight],\n              r = i[0],\n              o = i[1],\n              a = i[2],\n              l = i[3],\n              s = this.options;\n\n          if (!e.elementClone.initialized) {\n            var d = e.contextClone;\n            d.clearRect(r, o, a, l), d.save(), this.emit(\"beforePlate\"), this.drawBox = L(d, s, r, o, a, l), this.emit(\"beforeBar\"), X.apply(void 0, [d, s].concat(t(this.drawBox))), e.context.barDimensions = d.barDimensions, this.emit(\"beforeHighlights\"), q(d, s), this.emit(\"beforeMinorTicks\"), K(d, s), this.emit(\"beforeMajorTicks\"), $(d, s), this.emit(\"beforeNumbers\"), Q(d, s), this.emit(\"beforeTitle\"), ee(d, s), this.emit(\"beforeUnits\"), te(d, s), e.elementClone.initialized = !0;\n          }\n\n          this.canvas.commit(), e.context.clearRect(r, o, a, l), e.context.save(), e.context.drawImage(e.elementClone, r, o, a, l), e.context.save(), this.emit(\"beforeProgressBar\"), U.apply(void 0, [e.context, s].concat(t(this.drawBox))), this.emit(\"beforeNeedle\"), ie(e.context, s), this.emit(\"beforeValueBox\"), ae.apply(void 0, [e.context, s, s.animatedValue ? this.options.value : this.value].concat(t(this.drawBox))), se(n.prototype.__proto__ || Object.getPrototypeOf(n.prototype), \"draw\", this).call(this);\n        } catch (e) {\n          Te.verifyError(e);\n        }\n\n        return this;\n      }\n    }], [{\n      key: \"configure\",\n      value: function value(e) {\n        return e.barStrokeWidth >= e.barWidth && (e.barStrokeWidth = we(e.barWidth / 2)), e.hasLeft = Y(\"right\", e), e.hasRight = Y(\"left\", e), e.value > e.maxValue && (e.value = e.maxValue), e.value < e.minValue && (e.value = e.minValue), xe.configure(e);\n      }\n    }]), n;\n  }(xe);\n\n  void 0 !== e && (e.LinearGauge = Me), xe.initialize(\"LinearGauge\", Pe), \"undefined\" != typeof module && Object.assign(e, {\n    Collection: l,\n    GenericOptions: ge,\n    Animation: me,\n    BaseGauge: xe,\n    drawings: Te,\n    SmartCanvas: be,\n    DomObserver: ve,\n    vendorize: n\n  });\n}(\"undefined\" != typeof module ? module.exports : window);","map":null,"metadata":{},"sourceType":"script"}